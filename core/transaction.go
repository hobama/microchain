package core

import (
	"bytes"
	"encoding/json"
)

// The output field contains the following 3 entries:
// (1) The total number of transactions generated by the requester that have been accepted by the requestee.
// (2) The total number of transactions rejected by the requestee.
// (3) The hash of the public key that the requester will use for its next transaction.
type TXOutput struct {
	Accepted          int    `json:"accepted"`
	Rejected          int    `json:"rejected"`
	NextPublicKeyHash []byte `json:"next_pk_hash"`
}

type TransactionHeader struct {
	TransactionID      []byte `json:"id"`            // SHA256(requesterPK, requesteePK, timestamp)
	Timestamp          int    `json:"timestamp"`     // Unix timestamp
	PrevTransactionID  []byte `json:"previd"`        // Previous transaction ID
	RequesterPublicKey []byte `json:"requester_pk"`  // Requester public key
	RequesterSignature []byte `json:"requester_sig"` // Requester signature
	RequesteePublicKey []byte `json:"requestee_pk"`  // Requestee public key
	RequesteeSignature []byte `json:"requestee_sig"` // Requestee signature
}

type Transaction struct {
	Header TransactionHeader `json:"header"` // Header
	Meta   []byte            `json:"meta"`   // Meta data field
	Output TXOutput          `json:"output"` // TXOutput
}

// Test if two TXOutputs are equal.
func (txo TXOutput) EqualWith(temp TXOutput) bool {
	if txo.Accepted != temp.Accepted {
		return false
	}

	if txo.Rejected != temp.Rejected {
		return false
	}

	if !bytes.Equal(StripBytes(txo.NextPublicKeyHash, 0), StripBytes(temp.NextPublicKeyHash, 0)) {
		return false
	}

	return true
}

// Serialize TXOutput into Json.
func (txo TXOutput) MarshalJson() ([]byte, error) {
	return json.Marshal(txo)
}

// Read TXOutput from Json.
func (txo *TXOutput) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &txo)
}

// Test if two transaction headers are equal.
func (h TransactionHeader) EqualWith(temp TransactionHeader) bool {
	if !bytes.Equal(StripBytes(h.TransactionID, 0), StripBytes(temp.TransactionID, 0)) {
		return false
	}

	if h.Timestamp != temp.Timestamp {
		return false
	}

	if !bytes.Equal(StripBytes(h.PrevTransactionID, 0), StripBytes(temp.PrevTransactionID, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesterPublicKey, 0), StripBytes(temp.RequesterPublicKey, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesterSignature, 0), StripBytes(temp.RequesterSignature, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesteePublicKey, 0), StripBytes(temp.RequesteePublicKey, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesteeSignature, 0), StripBytes(temp.RequesteeSignature, 0)) {
		return false
	}

	return true
}

// Serialize transaction header into Json.
func (th TransactionHeader) MarshalJson() ([]byte, error) {
	return json.Marshal(th)
}

// Read transaction header from Json.
func (th *TransactionHeader) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &th)
}

// Test if two transactions are equal.
func (t Transaction) EqualWith(temp Transaction) bool {
	if !t.Header.EqualWith(temp.Header) {
		return false
	}

	if !bytes.Equal(StripBytes(t.Meta, 0), StripBytes(temp.Meta, 0)) {
		return false
	}

	if !t.Output.EqualWith(temp.Output) {
		return false
	}

	return true
}

// Serialize transaction into Json.
func (tr Transaction) MarshalJson() ([]byte, error) {
	return json.Marshal(tr)
}

// Read transaction from Json.
func (tr *Transaction) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &tr)
}

// TODO: We have 2 ways to represent transactions in a block
// (1) TransactionSlice: Consume lower memory, but low performace
// (2) TransactionsMap: High performance, but consume more memory
type TransactionSlice []Transaction

// Test if given tansaction is contained in the trs.
func (trs TransactionSlice) Contains(tr Transaction) (bool, int) {
	for i, t := range trs {
		if bytes.Equal(tr.Header.TransactionID, t.Header.TransactionID) {
			return true, i
		}
	}

	return false, 0
}

// Test if transaction with given id is contained in the trs.
func (trs TransactionSlice) ContainsByID(id []byte) (bool, int) {
	for i, t := range trs {
		if bytes.Equal(id, t.Header.TransactionID) {
			return true, i
		}
	}

	return false, 0
}

// Append new transaction to transaction trs.
func (trs TransactionSlice) Append(tr Transaction) TransactionSlice {
	return append(trs, tr)
}

// Insert new transaction to transaction trs.
func (trs TransactionSlice) Insert(tr Transaction) TransactionSlice {
	for i, t := range trs {
		if t.Header.Timestamp >= tr.Header.Timestamp {
			return append(append(trs[:i], tr), trs[i:]...)
		}
	}

	return trs.Append(tr)
}

// Test if two transaction trss are equal.
func (trs TransactionSlice) EqualWith(temp TransactionSlice) bool {
	if len(trs) != len(temp) {
		return false
	}

	for i, t := range trs {
		if !t.EqualWith(temp[i]) {
			return false
		}
	}

	return true
}

// Serialize transaction slice into Json.
func (trs TransactionSlice) MarshalJson() ([]byte, error) {
	return json.Marshal(trs)
}

// Read transaction slice from Json.
func (trs *TransactionSlice) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &trs)
}

// Diff on transactions.
func DiffTransactions(tl1, tl2 TransactionSlice) TransactionSlice {
	var diff TransactionSlice
	lastj := 0

	for _, t1 := range tl1 {
		found := false

		for j := lastj; j < len(tl2); j++ {
			// We assume tl1 and tl2 are sorted, so we could diff them in O(n).
			if bytes.Equal(StripBytes(t1.Header.TransactionID, 0), StripBytes(tl2[j].Header.TransactionID, 0)) {
				found = true
				lastj = j
				break
			}
		}

		if !found {
			diff = append(diff, t1)
		}
	}

	return diff
}
