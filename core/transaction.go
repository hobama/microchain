package core

import (
	"bytes"
	"encoding/json"
)

// TXOutput ... The output field contains the following 2 entries:
// (1) The total number of transactions generated by the requester that have been accepted by the requestee.
// (2) The total number of transactions rejected by the requestee.
type TXOutput struct {
	Accepted int `json:"accepted"`
	Rejected int `json:"rejected"`
}

// TransactionHeader ...
type TransactionHeader struct {
	TransactionID      []byte // SHA256(requesterPK, requesteePK, timestamp)
	Timestamp          int    // Unix timestamp
	PrevTransactionID  []byte // Previous transaction ID
	RequesterPublicKey []byte // Requester public key
	RequesterSignature []byte // Requester signature
	RequesteePublicKey []byte // Requestee public key
	RequesteeSignature []byte // Requestee signature
}

// TransactionHeaderJSONImpl ...
type TransactionHeaderJSONImpl struct {
	TransactionID      string `json:"id"`            // SHA256(requesterPK, requesteePK, timestamp)
	Timestamp          int    `json:"timestamp"`     // Unix timestamp
	PrevTransactionID  string `json:"prev_id"`       // Previous transaction ID
	RequesterPublicKey string `json:"requester_pk"`  // Requester public key
	RequesterSignature string `json:"requester_sig"` // Requester signature
	RequesteePublicKey string `json:"requestee_pk"`  // Requestee public key
	RequesteeSignature string `json:"requestee_sig"` // Requestee signature
}

// Transaction ...
type Transaction struct {
	Header TransactionHeader // Header
	Meta   []byte            // Meta data field
	Output TXOutput          // TXOutput
}

// TransactionJSONImpl ...
type TransactionJSONImpl struct {
	Header TransactionHeader `json:"header"`
	Meta   []byte            `json:"meta"`
	Output TXOutput          `json:"output"`
}

// EqualWith ... Test if two TXOutputs are equal.
func (txo TXOutput) EqualWith(temp TXOutput) bool {
	if txo.Accepted != temp.Accepted {
		return false
	}

	if txo.Rejected != temp.Rejected {
		return false
	}

	return true
}

// MarshalJson ... Serialize TXOutput into Json.
func (txo TXOutput) MarshalJson() ([]byte, error) {
	return json.Marshal(txo)
}

// UnmarshalJson ... Read TXOutput from Json.
func (txo *TXOutput) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &txo)
}

// EqualWith ... Test if two transaction headers are equal.
func (h TransactionHeader) EqualWith(temp TransactionHeader) bool {
	if !bytes.Equal(StripBytes(h.TransactionID, 0), StripBytes(temp.TransactionID, 0)) {
		return false
	}

	if h.Timestamp != temp.Timestamp {
		return false
	}

	if !bytes.Equal(StripBytes(h.PrevTransactionID, 0), StripBytes(temp.PrevTransactionID, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesterPublicKey, 0), StripBytes(temp.RequesterPublicKey, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesterSignature, 0), StripBytes(temp.RequesterSignature, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesteePublicKey, 0), StripBytes(temp.RequesteePublicKey, 0)) {
		return false
	}

	if !bytes.Equal(StripBytes(h.RequesteeSignature, 0), StripBytes(temp.RequesteeSignature, 0)) {
		return false
	}

	return true
}

// MarshalJSON ... Serialize transaction header into Json.
func (h TransactionHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(&TransactionHeaderJSONImpl{
		TransactionID:      Base58Encode(h.TransactionID),
		Timestamp:          h.Timestamp,
		PrevTransactionID:  Base58Encode(h.PrevTransactionID),
		RequesterPublicKey: Base58Encode(h.RequesterPublicKey),
		RequesterSignature: Base58Encode(h.RequesterSignature),
		RequesteePublicKey: Base58Encode(h.RequesteePublicKey),
		RequesteeSignature: Base58Encode(h.RequesteeSignature),
	})
}

// UnmarshalJSON ... Read transaction header from Json.
func (h *TransactionHeader) UnmarshalJSON(data []byte) error {
	var hJSONImpl TransactionHeaderJSONImpl

	err := json.Unmarshal(data, &hJSONImpl)
	if err != nil {
		return err
	}

	h.TransactionID = Base58Decode(hJSONImpl.TransactionID)
	h.Timestamp = hJSONImpl.Timestamp
	h.PrevTransactionID = Base58Decode(hJSONImpl.PrevTransactionID)
	h.RequesterPublicKey = Base58Decode(hJSONImpl.RequesterPublicKey)
	h.RequesterSignature = Base58Decode(hJSONImpl.RequesterSignature)
	h.RequesteePublicKey = Base58Decode(hJSONImpl.RequesteePublicKey)
	h.RequesteeSignature = Base58Decode(hJSONImpl.RequesteeSignature)

	return nil
}

// ID ... Get transaction id.
func (t Transaction) ID() []byte {
	return t.Header.TransactionID
}

// Timestamp ... Get timestamp.
func (t Transaction) Timestamp() int {
	return t.Header.Timestamp
}

// PreviousID ... Get previous transaction id.
func (t Transaction) PreviousID() []byte {
	return t.Header.PrevTransactionID
}

// RequesterPK ... Get requester public key.
func (t Transaction) RequesterPK() []byte {
	return t.Header.RequesterPublicKey
}

// RequesterSig ... Get requester signature.
func (t Transaction) RequesterSig() []byte {
	return t.Header.RequesterSignature
}

// RequesteePK ... Get requestee public key.
func (t Transaction) RequesteePK() []byte {
	return t.Header.RequesteePublicKey
}

// RequesteeSig ... Get requestee signature.
func (t Transaction) RequesteeSig() []byte {
	return t.Header.RequesteeSignature
}

// Out ... Get output field of transaction.
func (t Transaction) Out() TXOutput {
	return t.Output
}

// Accepted ... Get accepted number of transaction.
func (t Transaction) Accepted() int {
	return t.Output.Accepted
}

// Rejected ... Get rejected number of transaction.
func (t Transaction) Rejected() int {
	return t.Output.Rejected
}

// Hash ... Get SHA256 sum of transaction meta field.
func (t Transaction) Hash() []byte {
	return SHA256(t.Meta)
}

// EqualWith ... Test if two transactions are equal.
func (t Transaction) EqualWith(temp Transaction) bool {
	if !t.Header.EqualWith(temp.Header) {
		return false
	}

	if !bytes.Equal(StripBytes(t.Meta, 0), StripBytes(temp.Meta, 0)) {
		return false
	}

	if !t.Output.EqualWith(temp.Output) {
		return false
	}

	return true
}

// MarshalJSON ... Serialize transaction into Json.
func (t Transaction) MarshalJSON() ([]byte, error) {

	return json.Marshal(&TransactionJSONImpl{
		Header: t.Header,
		Meta:   t.Meta,
		Output: t.Output,
	})
}

// UnmarshalJSON ... Read transaction from Json.
func (t *Transaction) UnmarshalJSON(data []byte) error {
	var tt TransactionJSONImpl

	err := json.Unmarshal(data, &tt)
	if err != nil {
		return err
	}

	t.Header = tt.Header
	t.Meta = tt.Meta
	t.Output = tt.Output

	return nil
}

// VerifyTransactionID ... Verify transaction id.
func (t Transaction) VerifyTransactionID() bool {
	requesterPK := t.RequesterPK()
	requesteePK := t.RequesteePK()
	timestamp := t.Timestamp()

	timestampBytes := UInt64ToBytes(uint64(timestamp))

	sha256Sum := SHA256(JoinBytes(requesterPK, requesteePK, timestampBytes))

	return bytes.Equal(t.ID(), sha256Sum)
}

// VerifyRequesterSig ... Verify requester signature.
func (t Transaction) VerifyRequesterSig() bool {
	return VerifySignature(t.RequesterPK(), t.RequesterSig(), t.Hash())
}

// VerifyRequesteeSig ... Verify requestee signature.
func (t Transaction) VerifyRequesteeSig() bool {
	return VerifySignature(t.RequesteePK(), t.RequesteeSig(), t.Hash())
}

// IsGenesisTransaction ... Test if it's genesis transaction.
func (t Transaction) IsGenesisTransaction() bool {
	return bytes.Equal(t.ID(), t.PreviousID())
}

// TransactionSlice ...
type TransactionSlice []Transaction

func (ts TransactionSlice) Len() int           { return len(ts) }
func (ts TransactionSlice) Swap(i, j int)      { ts[i], ts[j] = ts[j], ts[i] }
func (ts TransactionSlice) Less(i, j int) bool { return ts[i].Timestamp() < ts[j].Timestamp() }

// TODO: We have 2 ways to represent transactions in a block
// (1) TransactionSlice: Consume lower memory, but low performace
// (2) TransactionsMap: High performance, but consume more memory

// Contains ... Test if given tansaction is contained in the trs.
func (ts TransactionSlice) Contains(tr Transaction) (bool, int) {
	for i, t := range ts {
		if bytes.Equal(tr.ID(), t.ID()) {
			return true, i
		}
	}

	return false, 0
}

// ContainsByID ... Test if transaction with given id is contained in the trs.
func (ts TransactionSlice) ContainsByID(id []byte) (bool, int) {
	for i, t := range ts {
		if bytes.Equal(id, t.ID()) {
			return true, i
		}
	}

	return false, 0
}

// Append ... Append new transaction to transaction trs.
func (ts TransactionSlice) Append(t Transaction) TransactionSlice {
	return append(ts, t)
}

// Insert ... Insert new transaction to transaction trs.
func (ts TransactionSlice) Insert(tr Transaction) TransactionSlice {
	for i, t := range ts {
		if t.Header.Timestamp >= tr.Header.Timestamp {
			return append(append(ts[:i], tr), ts[i:]...)
		}
	}

	return ts.Append(tr)
}

// EqualWith ... Test if two transaction trss are equal.
func (ts TransactionSlice) EqualWith(temp TransactionSlice) bool {
	if len(ts) != len(temp) {
		return false
	}

	for i, t := range ts {
		if !t.EqualWith(temp[i]) {
			return false
		}
	}

	return true
}

// MarshalJson ... Serialize transaction slice into Json.
func (ts TransactionSlice) MarshalJson() ([]byte, error) {
	return json.Marshal(ts)
}

// UnmarshalJson ... Read transaction slice from Json.
func (ts *TransactionSlice) UnmarshalJson(data []byte) error {
	return json.Unmarshal(data, &ts)
}

// GetTransactionByID ... Get transaction by transaction id.
func (ts TransactionSlice) GetTransactionByID(id []byte) (bool, Transaction) {
	for _, tr := range ts {
		if bytes.Equal(tr.ID(), id) {
			return true, tr
		}
	}

	return false, Transaction{}
}

// DiffTransactions ... Diff on transactions.
func DiffTransactions(tl1, tl2 TransactionSlice) TransactionSlice {
	var diff TransactionSlice
	lastj := 0

	for _, t1 := range tl1 {
		found := false

		for j := lastj; j < len(tl2); j++ {
			// We assume tl1 and tl2 are sorted, so we could diff them in O(n).
			if bytes.Equal(StripBytes(t1.ID(), 0), StripBytes(tl2[j].ID(), 0)) {
				found = true
				lastj = j
				break
			}
		}

		if !found {
			diff = append(diff, t1)
		}
	}

	return diff
}
