package core

import (
	"bytes"
	"fmt"
	"time"
)

const (
	TransactionIDLength     = 32
	TimestampLength         = 4
	PublicKeyLength         = 64
	SignatureLength         = 32
	TransactionHeaderLength = 268
)

// The output field contains the following 3 entries:
// (1) The total number of transactions generated by the requester that have been accepted by the requestee.
// (2) The total number of transactions rejected by the requestee.
// (3) The hash of the public key that the requester will use for its next transaction.
type Output struct {
	Accepted          uint64
	Rejected          uint64
	NextPublicKeyHash []byte
}

type TransactionHeader struct {
	TransactionID      []byte // SHA256(requesterPK, requesteePK, timestamp) : 256-bits : 32-bytes
	Timestamp          uint32 // Unix timestamp                              : 32-bits  : 4-byte
	PrevTransactionID  []byte // Previous transaction ID                     : 256-bits : 32-bytes
	RequesterPublicKey []byte // Base58 encoding of requester public key     : 512-bits : 64-bytes
	RequesterSignature []byte // Base58 encoding of requester signature      : 256-bits : 32-bytes
	RequesteePublicKey []byte // Base58 encoding of requestee public key     : 512-bits : 64-bytes
	RequesteeSignature []byte // Base58 encoding of requestee signature      : 256-bits : 32-bytes
	MetaLength         uint64 // Meta data length                            : 64-bits  : 8-bytes
}

type Transaction struct {
	Header TransactionHeader // Header
	Meta   []byte            // Meta data field
}

// We use requesterID, requesteeID, timestamp to identify a transaction in blocks.
func NewTransaction(from, to, meta []byte) *Transaction {
	time := uint32(time.Now().Unix())
	transaction := Transaction{
		Header: TransactionHeader{
			Timestamp:          time,
			RequesterPublicKey: from,
			RequesteePublicKey: to,
			MetaLength:         uint64(len(meta))},
		Meta: meta}
	timeBuf := UInt32ToBytes(time)
	rawid := JoinBytes(timeBuf, from, to)
	transaction.Header.TransactionID = SHA256(rawid)
	return &transaction
}

func (header *TransactionHeader) MarshalBinary() ([]byte, error) {
	buf := new(bytes.Buffer)
	buf.Write(FitBytesIntoSpecificWidth(header.TransactionID, TransactionIDLength))
	buf.Write(UInt32ToBytes(header.Timestamp))
	buf.Write(FitBytesIntoSpecificWidth(header.PrevTransactionID, TransactionIDLength))
	buf.Write(FitBytesIntoSpecificWidth(header.RequesterPublicKey, PublicKeyLength))
	buf.Write(FitBytesIntoSpecificWidth(header.RequesterSignature, SignatureLength))
	buf.Write(FitBytesIntoSpecificWidth(header.RequesteePublicKey, PublicKeyLength))
	buf.Write(FitBytesIntoSpecificWidth(header.RequesteeSignature, SignatureLength))
	buf.Write(UInt64ToBytes(header.MetaLength))
	return buf.Bytes(), nil
}
